else if (tipoIngreso.toLowerCase() === 'parcial') {


  const consecutivo = await this.prismaNovasoftService.$queryRawUnsafe<any[]>(`
    SELECT ISNULL(MAX(CONVERT(INT, num_doc)), 0) + 1 AS numDoc
    FROM inv_inf_inv
  `);

  num_doc = consecutivo[0]?.numDoc;
  if (!num_doc || isNaN(num_doc)) {
    throw new Error("Error al generar consecutivo para ingreso parcial.");
  }


 const hayFactura = cantidadesAuraParcial.some(
  a => (a.factura || '').trim() !== ''
);

if (!hayFactura) {
  throw new BadRequestException(
    `No se encontró ninguna factura válida para la referencia ${obs_orc} y la OC ${num_o}`
  );
}
  

  for (const aura of cantidadesAuraParcial) {

    const CantidadT = Number(aura.CantidadT);
    const factura = (aura.factura || '').trim();

    

if (!factura) continue;
let CantidadI = Number(aura.CantidadI);
let CantidadR = Number(aura.CantidadR || 0);

if (CantidadR === 0) continue;
 const facturasValidas = consulfactura.map(f => (f.factura || '').trim());
  if (!facturasValidas.includes(factura)) continue;
if (CantidadR > (CantidadT - CantidadI)) {
  CantidadR = CantidadT - CantidadI;
}

CantidadI = CantidadI + CantidadR;
const CantidadPendiente = CantidadT - CantidadI;
console.log(CantidadPendiente)

if (CantidadPendiente <= 0) continue;


 

  
const codigoAura = String(aura.codItem).split(' - ')[0].trim();
console.log('--- DEBUG MATCH ---')
  console.log('ITEMS AURA:', codigoAura);
  console.log('ITEMS NOVA:', items.map(i => i.item));


const normalizar = (v: string) =>
  v.replace(/\s+/g, '').toUpperCase();

const novas = items.filter(
  i => normalizar(i.item) === normalizar(codigoAura)
);

if (novas.length === 0) continue;
const CantidadRCalc = CantidadPendiente;

let restante = CantidadRCalc;

for (const nova of novas) {
 if (restante <= 0) break;

  const cantidadNova = Number(nova.cantidad || 0);

  if (cantidadNova <= 0) continue;
const yaIngresado = mapIngresado.get(codigoAura) || 0;

const pendienteReal = CantidadT - yaIngresado; // CantidadR = recibida anterior
if (pendienteReal <= 0) continue;
  const cantidadInsertar = Math.min(restante, cantidadNova);    
