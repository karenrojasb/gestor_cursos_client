import { queryAura } from '../database/auraPool'; // tu pool de AuraQuantic

export async function obtenerSubTip(referencia: string) {
  // Consulta SQL para obtener asig_numero
  const sql = `
    DECLARE @Referencia CHAR(20) = '${referencia}';
    DECLARE @asig_numero CHAR(14);
    DECLARE @sub_tip CHAR(5);

    -- Paso 1: obtener el asig_numero
    SELECT @asig_numero = asig_numero
    FROM inv_inf_inv
    WHERE obs_orc LIKE '%' + @Referencia + '%';

    -- Paso 2: determinar sub_tip
    SET @sub_tip = CASE 
        WHEN LEFT(@asig_numero, 2) IN ('OS', 'OC') THEN 'C008'
        WHEN LEFT(@asig_numero, 2) = 'PF' THEN 'PFIN'
        WHEN LEFT(@asig_numero, 2) = 'CN' THEN 'NCIN'
        ELSE NULL
    END;

    -- Paso 3: mostrar resultado
    SELECT @asig_numero AS asig_numero, @sub_tip AS sub_tip;
  `;

  try {
    const result = await queryAura(sql); // ejecuta la consulta con tu Pool
    return result[0]; // devuelve el primer registro
  } catch (error) {
    console.error('Error obteniendo sub_tip:', error);
    throw error;
  }
}import { Injectable } from '@nestjs/common';
import { PrismaNovasoftService } from 'src/prismaNovasoft/prismaNovasoft.service';
import { getCurrentMonth, getNowDate, formatoDateToDDMMYYYY } from 'src/utils/date.util'; 
import { generarIngresoDto } from './dto/generaringreso.dto';
import { PrismaAuraquanticService } from 'src/prismaAuraquantic/prismaAuraquantic.service';

@Injectable()
export class GenerarIngresoService {
  constructor(
    private readonly prismaNovasoftService: PrismaNovasoftService,
    private readonly prismaAuraquanticService: PrismaAuraquanticService

  ) {}

  async generarIngreso(data: generarIngresoDto ) {
    const { referencia, tipo, ano_o, per_o, num_o, solicitante, _ElementID } = data;

    
    //Declaración de variables
    let tipoIngreso: string;
    let contenedorIngreso: string;
    let subProceso: string;

    //Switch para asignar valores según el tipo
    switch (tipo.toLowerCase()) {
      case 'contractual':
        tipoIngreso = 'contractual';
        contenedorIngreso = '73';
        subProceso = 'Contractual';
        break;
      case 'regular':
        tipoIngreso = 'regular';
        contenedorIngreso = '110';
        subProceso = 'Regular';
        break;
      case 'proveedor unico':
        tipoIngreso = 'proveedor unico';
        contenedorIngreso = '128';
        subProceso = 'Proveedor Único';
        break;
      case 'transporte':
        tipoIngreso = 'transporte';
        contenedorIngreso = '';
        subProceso = 'transporte';
        break;
      default:
        throw new Error(`Tipo no reconocido: ${tipo}`);
    }

    //Constante de tipo de documento
    const INGRESOALMACEN = '008';

    //Consulta de subtipo
    const cod_sub = await this.prismaNovasoftService.$queryRawUnsafe<any[]>(`
      SELECT cod_sub 
      FROM gen_subtipodoc 
      WHERE cod_tip = '${INGRESOALMACEN}' 
        AND cod_sub LIKE '${tipoIngreso.charAt(0).toUpperCase()}%'
    `);
   


    
    const cantidadesAura = await this.prismaAuraquanticService.$queryRawUnsafe<any[]>(`
        SELECT ID, 
        [2_ART_CON_GAN/TXT_UP_ARTICULO] + ' - ' + [1_ART_CON_GAN/Name] codItem, 
        [2_ART_CON_GAN/CANTIDAD_ART] CantidadT, 
        ISNULL([2_ART_CON_GAN/ENT_CANT_ERP], 0) CantidadI, 
        ISNULL([2_ART_CON_GAN/ENT_CANT_RECIBIDA], 0) CantidadR, 
        ISNULL([2_ART_CON_GAN/TXT_NUM_FACTURA], '') factura 
FROM Panel_109_68508_83802 
        WHERE [_ElementID] = ${_ElementID}
        ORDER BY ID
      `);
      

      const subtipo = cod_sub[0].cod_sub;

    //Consulta de items
    const consultaitems = `
    DECLARE @sub_o CHAR(5);
    DECLARE @ano_o CHAR(4) = '${ano_o}';
    DECLARE @per_o CHAR(2) = '${per_o}';
    DECLARE @num_o CHAR(14) = '${num_o}';
    DECLARE @fec_a DATE = '${formatoDateToDDMMYYYY()}';
    DECLARE @sub_a CHAR(5) = '${subtipo}';
    DECLARE @tip_a CHAR(5) = (SELECT cod_tip FROM gen_subtipodoc WHERE cod_sub = '${subtipo}');
    DECLARE @referencia CHAR(20) = '${referencia}';
    

    IF EXISTS   (
                SELECT sub_tip 
                FROM inv_inf_inv 
                WHERE   asig_numero = @num_o 
                AND tip_doc = '007' 
                AND obs_orc LIKE '%' + @Referencia + '%' )	
BEGIN 
    SELECT @sub_o = sub_tip 
    FROM inv_inf_inv 
    WHERE   asig_numero = @num_o 
    AND tip_doc = '007' 
    AND obs_orc LIKE '%' + @Referencia + '%'; 	
END; 
ELSE 
BEGIN 
    SELECT @sub_o = sub_tip 
    FROM inv_cuedoc 
    WHERE  num_doc = @num_o 
    AND tip_doc = '007'
    AND ano_doc = @ano_o 
    AND per_doc = @per_o 
END; 

SELECT      CONVERT(CHAR(4), FORMAT(@fec_a, 'yyyy')) ano_doc, CONVERT(CHAR(2), 
FORMAT(@fec_a, 'MM')) per_doc, @sub_a sub_tip, @tip_a tip_doc, '' num_doc, 
            CUE.reg_doc, CONVERT(VARCHAR(MAX), @fec_a, 112) fecha, CAB.vendedor, 
        CAB.cod_suc, CUE.cod_cco, 
            CUE.cod_cl1, CUE.cod_cl2, CUE.cod_cl3, CAB.cliente, CAB.provee, 
            CAB.lista, CAB.dia_pla, CAB.ind_mp, CONVERT(VARCHAR(MAX), 
        CAB.fec_tas, 112) fec_tas, CAB.tasa, 
            CAB.obs_orc, CAB.fac_pro, CAB.cod_caja, CUE.bodega, CUE.bod_des, 
            CUE.cant_uni, CUE.item, CUE.alterno, '32002' trans, CONVERT(INT, 
        CUE.cantidad) cantidad, 
            + CUE.fac_con, CUE.cos_uni, CUE.pre_vta, CUE.por_des, CUE.por_iva, 
            CUE.por_iva_ng, CUE.por_ret, CUE.por_com, CUE.cos_unai, 
        CONVERT(VARCHAR(MAX), CUE.fec_ent, 112) fec_ent, 
            CUE.suc_des, CUE.ven_lote, CUE.cod_lote, '' ind_tra, 1 asig_num, 
            CUE.ind_refac, CUE.cod_conv, CUE.conv_suc, CUE.conv_cco, 
        CUE.conv_cl1, 
            CUE.conv_cl2, CUE.conv_cl3, CUE.num_fact, CUE.ord_fact, CUE.por_adm, 
            CUE.por_imp, CUE.por_uti, CUE.mon_adm, CUE.mon_imp, CUE.mon_uti, 
            NULL asig_numero, CUE.ind_afe, @ano_o usr_ano_ped, @per_o usr_per_ped, @sub_o usr_sub_ped, 
            @num_o usr_pedido, CUE.reg_doc usr_reg_ped, '${solicitante}' usr_tercero, 

            NULL ano_cdp, NULL per_cdp, 
            CUE.sub_cdp, CUE.num_cdp, CUE.cod_rubro, NULL usr_ano_des, NULL usr_per_des, 
            NULL usr_sub_des, NULL usr_despa, NULL usr_reg_des, CUE.descrip_cue usr_descrip_cue 
FROM   inv_cuedoc CUE 
    INNER JOIN inv_cabdoc CAB ON (
                                        CUE.ano_doc = CAB.ano_doc 
                                        AND CUE.per_doc = CAB.per_doc 
                                        AND CUE.sub_tip = CAB.sub_tip 
                                        AND CUE.num_doc = CAB.num_doc
                                    )
WHERE   CAB.ano_doc = @ano_o 
        AND CAB.per_doc = @per_o 
        AND CAB.sub_tip = @sub_o 
        AND CAB.num_doc = @num_o


    ` 
    const items = await this.prismaNovasoftService.$queryRawUnsafe<any[]>(`
    ${consultaitems}`);



    const cantidadAura = cantidadesAura.length;
    const cantidadNova = items.length;
    
    if (cantidadAura !== cantidadNova) {
      return {
        mensaje: `La cantidad de items de la orden '${referencia}' no es igual en ambos sistemas, no se puede generar el ingreso.`,
        referencia,
        cantidadAura,
        cantidadNova,
      };
    }

    let numDocConsecutivo = null;

if (tipoIngreso.toLowerCase() === 'completo') {

  const consecutivo = await this.prismaNovasoftService.$queryRawUnsafe<any[]>(`
    SELECT ISNULL(MAX(CONVERT(INT, num_doc)), 0) + 1 AS numDoc
    FROM inv_inf_inv
  `);

  numDocConsecutivo = consecutivo[0]?.numDoc;

  // Validación estricta
  if (!numDocConsecutivo || isNaN(numDocConsecutivo)) {
    throw new Error("Error al generar el consecutivo. No se puede continuar.");
  }


  for (let i = 0; i < cantidadesAura.length; i++) {
    const aura = cantidadesAura[i];
    const nova = items[i]; // Los datos que se usan para el INSERT
  
    const CantidadT = Number(aura.CantidadT);
    const CantidadI = Number(aura.CantidadI);
  
    // Validación
    if ((CantidadT - CantidadI) <= 0) continue;
  
    const CantidadR = CantidadT - CantidadI;
    const nuevaCantidadI = CantidadI + CantidadR;
  
    // Insert
   
    await this.prismaNovasoftService.$executeRawUnsafe(`
      INSERT INTO inv_inf_inv (
        ano_doc, per_doc, tip_doc, sub_tip, num_doc, reg_doc,
        fecha, vendedor, cod_suc, cod_cco, cod_cl1, cod_cl2,
        cod_cl3, cliente, provee, lista, dia_pla, ind_mp,
        fec_tas, tasa, obs_orc, bodega, bod_des, fac_pro,
        cod_caja, cant_uni, item, alterno, trans, cantidad,
        fac_con, cos_uni, pre_vta, por_des, por_iva, por_iva_ng,
        por_ret, por_com, cos_unai, fec_ent, suc_des, ind_tra,
        asig_num, ind_refac, cod_conv, conv_suc, conv_cco, conv_cl1,
        conv_cl2, conv_cl3, num_fact, ord_fact, por_adm, por_imp,
        por_uti, mon_adm, mon_imp, mon_uti, usr_ano_ped, usr_per_ped,
        usr_sub_ped, usr_pedido, usr_reg_ped, usr_tercero,
        cod_rubro, usr_descrip_cue, sub_cdp, num_cdp
      )
      VALUES (
        '${nova.ano_doc}', '${nova.per_doc}', '${nova.tip_doc}', '${nova.sub_tip}',
        '${numDocConsecutivo}', '${nova.reg_doc}',
        '${nova.fecha}', '${nova.vendedor}', '${nova.cod_suc}', '${nova.cod_cco}',
        '${nova.cod_cl1}', '${nova.cod_cl2}', '${nova.cod_cl3}', '${nova.cliente}',
        '${nova.provee}', '${nova.lista}', '${nova.dia_pla}', '${nova.ind_mp}',
        '${nova.fec_tas}', '${nova.tasa}', '${nova.obs_orc}', '${nova.bodega}',
        '${nova.bod_des}', '${nova.fac_pro}', '${nova.cod_caja}',
        '${nova.cant_uni}', '${nova.item}', '${nova.alterno}', '${nova.trans}',
        '${CantidadR}',        -- cantidad actualizada
        '${nova.fac_con}', '${nova.cos_uni}', '${nova.pre_vta}', '${nova.por_des}',
        '${nova.por_iva}', '${nova.por_iva_ng}', '${nova.por_ret}', '${nova.por_com}',
        '${nova.cos_unai}', '${nova.fec_ent}', '${nova.suc_des}', '${nova.ind_tra}',
        '${nova.asig_num}', '${nova.ind_refac}', '${nova.cod_conv}', '${nova.conv_suc}',
        '${nova.conv_cco}', '${nova.conv_cl1}', '${nova.conv_cl2}', '${nova.conv_cl3}',
        '${aura.factura}',    -- factura viene de AuraQuantic
        '${nova.ord_fact}', '${nova.por_adm}', '${nova.por_imp}', '${nova.por_uti}',
        '${nova.mon_adm}', '${nova.mon_imp}', '${nova.mon_uti}', '${nova.usr_ano_ped}',
        '${nova.usr_per_ped}', '${nova.usr_sub_ped}', '${nova.usr_pedido}',
        '${nova.usr_reg_ped}', '${nova.usr_tercero}', '${nova.cod_rubro}',
        '${nova.usr_descrip_cue}', '${nova.sub_cdp}', '${nova.num_cdp}'
      )
    `);
  }
}

// Ejecutar SP SOLO si fue tipo Completo
if (tipoIngreso.toLowerCase() === 'completo') {

    
  
    await this.prismaNovasoftService.$executeRawUnsafe(`
      EXEC dbo.USR_sp_gen_afeinv_preciso
        @iano_doc = '${getNowDate().getFullYear()}',
                            @fano_doc = '${getNowDate().getFullYear()}',
                            @iper_doc = '${getCurrentMonth()}',
                            @fper_doc = '${getCurrentMonth()}',
                            @isub_tip = '${subtipo}',
                            @fsub_tip = '${subtipo}',
                            @inum_doc = '${numDocConsecutivo}',
                            @fnum_doc = '${numDocConsecutivo}',
                            @ifec_doc = '${formatoDateToDDMMYYYY()}',
                            @ffec_doc = '${formatoDateToDDMMYYYY()}',
                            @indver = 0
    `);
  }


    //Validación de resultado
    if (cod_sub.length === 0) {
      return {
        mensaje: `No se encontró subtipo para el tipo ${tipoIngreso}`,
        tipoIngreso,
        contenedorIngreso,
        numDocConsecutivo,
        subProceso,
        subtipo: null,
        cantidaditems: items.length,
        items,
      };
    }

   


    //Retorno de datos
    return {
      referencia,
      tipoIngreso,
      contenedorIngreso,
      subProceso,
      numDocConsecutivo,
      cantidadesAura,
      subtipo,
      cantidaditems: items.length,
      items,
      
      
    };
    
  }
}
