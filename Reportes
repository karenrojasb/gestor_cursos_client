else if (tipoIngreso.toLowerCase() === 'parcial') {

  const consecutivo = await this.prismaNovasoftService.$queryRawUnsafe<any[]>(`
    SELECT ISNULL(MAX(CONVERT(INT, num_doc)), 0) + 1 AS numDoc
    FROM inv_inf_inv
  `);

  num_doc = consecutivo[0]?.numDoc;
  if (!num_doc || isNaN(num_doc)) {
    throw new Error("Error al generar consecutivo para ingreso parcial.");
  }

  const hayFactura = cantidadesAuraParcial.some(
    a => (a.factura || '').trim() !== ''
  );

  if (!hayFactura) {
    throw new BadRequestException(
      `No se encontrÃ³ ninguna factura vÃ¡lida para la referencia ${obs_orc} y la OC ${num_o}`
    );
  }

  for (const aura of cantidadesAuraParcial) {

    const CantidadT = Number(aura.CantidadT || 0);
    const CantidadR = Number(aura.CantidadR || 0);
    const factura = (aura.factura || '').trim();

    if (!factura) continue;
    if (CantidadR <= 0) continue;

    const facturasValidas = consulfactura.map(f => (f.factura || '').trim());
    if (!facturasValidas.includes(factura)) continue;

    // ðŸ”´ RESTA DEFINIDA POR TI
    const CantidadPendiente = CantidadR - CantidadT;

    console.log({
      item: aura.codItem,
      CantidadR,
      CantidadT,
      CantidadPendiente
    });

    if (CantidadPendiente <= 0) continue;

    const codigoAura = String(aura.codItem).split(' - ')[0].trim();

    const normalizar = (v: string) =>
      v.replace(/\s+/g, '').toUpperCase();

    const novas = items.filter(
      i => normalizar(i.item) === normalizar(codigoAura)
    );

    if (novas.length === 0) continue;

    let restante = CantidadPendiente;

    for (const nova of novas) {
      if (restante <= 0) break;

      const cantidadNova = Number(nova.cantidad || 0);
      if (cantidadNova <= 0) continue;

      const yaIngresado = mapIngresado.get(codigoAura) || 0;
      const pendienteRealERP = CantidadPendiente - yaIngresado;

      if (pendienteRealERP <= 0) break;

      const cantidadInsertar = Math.min(
        restante,
        cantidadNova,
        pendienteRealERP
      );

      if (cantidadInsertar <= 0) continue;

   